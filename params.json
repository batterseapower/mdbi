{"name":"MDBI","tagline":"Max's DataBase Interface: a simple but powerful JDBC wrapper inspired by JDBI","body":"### Welcome to GitHub Pages.\r\n[Java Database Connectivity (JDBC)](https://en.wikipedia.org/wiki/Java_Database_Connectivity) is inescapable if you want to talk to a SQL database from Java. Unfortanately, JDBC is an API that is absolutely no fun to use!\r\n\r\nMDBI is a wrapper around JDBC that takes the pain away, loosely inspired by [JDBI](http://jdbi.org/) and Harriet Cooper's Phi library for Scala.\r\n\r\n### The basics\r\n\r\nGetting started with MDBI is easy: all you need is a `javax.sql.DataSource` or `Connection`:\r\n\r\n    final Connection conn = DriverManager.getConnection(\"jdbc:sqlite::memory:\");\r\n    MDBI.of(conn).execute(sql(\"create table people (name text, age int)\"));\r\n\r\nAs well as executing raw SQL, it is of course possible to interpolate Java objects into the query:\r\n\r\n    final String name = \"Michael O'Hare\";\r\n    MDBI.of(conn).execute(sql(\"insert into people (name, age) values (\").$(name).sql(\", 30)\"));\r\n\r\nTo get back Java objects from the database, simply use a \"query\" method rather than \"execute\":\r\n\r\n    final int age = MDBI.of(conn).queryFirst(sql(\"select age from people\"), int.class);\r\n    println(age); // 30\r\n\r\n### NULL safety\r\n\r\nMost people who work with JDBC have been burned at some point by the fact that it silently\r\nturns `NULL`s in the database into zeroes, which is almost never what you want. MDBI removes\r\nthis misfeature, so the following query actually throws a NullPointerException:\r\n\r\n    MDBI.of(conn).queryFirst(sql(\"select null\"), int.class);\r\n\r\nOf course, you can still retrieve nulls if you explicitly ask for them:\r\n\r\n    final Integer nully = MDBI.of(conn).queryFirst(sql(\"select null\"), Integer.class);\r\n    println(nully); // null\r\n\r\nNote that database NULLs *are* supported when retrieving primitive doubles and floats, where\r\nthey can be cleanly mapped to NaNs:\r\n\r\n    final double nullyDouble = MDBI.of(conn).queryFirst(sql(\"select null\"), double.class);\r\n    println(nullyDouble); // NaN\r\n\r\n### Batch update\r\n\r\nBatch statements are of course fully supported:\r\n\r\n    final List<String> names = Arrays.asList(\"Fry\", \"Leela\");\r\n    final List<Integer> ages = Arrays.asList(1025, 25);\r\n    MDBI.of(conn).updateBatch(sql(\"insert into people (name, age) values (\")\r\n                                            .$s(names).sql(\",\").$s(ages).sql(\")\"));\r\n\r\nYou can even mix batched and non-batched bits of the query:\r\n\r\n    final List<String> moreNames = Arrays.asList(\"Foo\", \"Bar\");\r\n    final int anotherAge = 13;\r\n    MDBI.of(conn).updateBatch(sql(\"insert into people (name, age) values (\")\r\n                                            .$s(moreNames).sql(\",\").$(anotherAge).sql(\")\"));\r\n\r\n### Conveniences\r\n\r\nMDBI has built-in support for `IN` clauses:\r\n\r\n    final List<Integer> foundAges = MDBI.of(conn).queryList(\r\n                            sql(\"select age from people where name \").in(\"Fry\", \"Foo\"), int.class);\r\n    println(foundAges); // [1025, 13]\r\n\r\nThese `IN` clauses work properly with empty argument lists, even if the database does not normally support\r\nnullary `IN` clauses (and most databases don't):\r\n\r\n    final int count = MDBI.of(conn).queryFirst(\r\n                            sql(\"select count(*) from people where name not \").in(), int.class);\r\n    println(count); // 5\r\n\r\nThere is also transaction support that's really easy to use (no messing around with the confusing `setAutoCommit` interface):\r\n\r\n    try {\r\n        Transactionally.run(conn, () -> {\r\n            MDBI.of(conn).execute(sql(\"insert into people (name, age) values ('foo', 1)\"));\r\n            throw new IllegalArgumentException(\"Changed my mind!\");\r\n        });\r\n    } catch (IllegalArgumentException _) {}\r\n\r\n    final int postTransactionCount = MDBI.of(conn).queryFirst(\r\n                                        sql(\"select count(*) from people\"), int.class);\r\n    println(postTransactionCount); // 5\r\n\r\n### Structured result types\r\n\r\nSo far we've shown how to retrieve single rows and lists from the datbase. But MDBI has native support for\r\nother useful types of result. For example:\r\n\r\n    final Map<String, Integer> ageMap = MDBI.of(conn).queryMap(\r\n                                        sql(\"select name, age from people\"), String.class, int.class);\r\n    println(ageMap.get(\"Fry\")); // 1025\r\n\r\nOne option that is particularly handy is the \"matrix\":\r\n\r\n    final Object[] matrix = MDBI.of(conn).query(sql(\"select name, age from people order by name\"),\r\n                                                BatchReads.matrix(String.class, int.class));\r\n    final String[] nameColumn = (String[])matrix[0];\r\n    final int[] ageColumn = (int[])matrix[1];\r\n    println(nameColumn[0] + \": \" + ageColumn[1]); // Bar: 13\r\n\r\n### Custom type mapping\r\n\r\nMDBI has great support for Java primitive types, but it can also be extended with support for your own types. Let's say\r\nyou have a bean, `PersonBean`, with `Name` and `Age` properties. This works:\r\n\r\n    final Context ctxt0 = Context.Builder.createDefault()\r\n            .registerRead(PersonBean.class, Reads.bean(PersonBean.class, \"Name\", \"Age\"))\r\n            .build();\r\n    final PersonBean bean = MDBI.of(ctxt0, conn).queryFirst(\r\n                                sql(\"select name, age from people order by name\"), PersonBean.class);\r\n    println(bean.getName()); // Bar\r\n\r\nIf you don't like beans, that's no problem. There are also strongly-typed interfaces suitable for immutable data types. For\r\nexample, if we have defined a `Person` type as follows:\r\n\r\n    public class Person {\r\n        public final String name;\r\n        public final int age;\r\n\r\n        public Person(String name, int age) {\r\n            this.name = name;\r\n            this.age = age;\r\n        }\r\n    }\r\n\r\nThen we can read this back from the database as follows:\r\n\r\n    final Context ctxt1 = Context.Builder.createDefault()\r\n            .registerRead(Person.class, Reads.tuple(Person.class))\r\n            .build();\r\n    final Person person = MDBI.of(ctxt1, conn).queryFirst(\r\n                            sql(\"select name, age from people order by name\"), Person.class);\r\n    println(person.name); // Bar\r\n\r\nWe've shown how you can read your custom types back from the database, but custom types are also usable when you are\r\nconstructing SQL queries. You just need to use `Context.registerWrite` instead of `Context.registerRead`:\r\n\r\n    final Context ctxt2 = Context.Builder.createDefault()\r\n            .registerWrite(Person.class, TupleWriteBuilder.<Person>create()\r\n                                            .add(String.class, p -> p.name)\r\n                                            .add(int.class,    p -> p.age)\r\n                                            .build())\r\n            .build();\r\n    final Person personToSave = new Person(\"Max\", 29);\r\n    MDBI.of(ctxt2, conn).execute(sql(\"insert into people (name, age) values (\").$(personToSave).sql(\")\"));\r\n\r\n### Conclusion\r\n\r\nThere are lots more features besides:\r\n * Deadlocks are automatically retried. (The retry policy is fully customizable.)\r\n * Java 8 date and time types are fully supported\r\n * Support for both PreparedStatement and Statement. This can be useful when working with a database\r\n   that e.g. scopes the lifetime of temp tables to a prepared statement.\r\n\r\nAll of this comes with no runtime dependencies at all -- you only need the JDK.\r\n\r\nTo get started, grab a jar from [Maven Central](TODO) TODO and check out the [JavaDocs](TODO) TODO.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}