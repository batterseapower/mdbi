{"name":"MDBI","tagline":"Max's DataBase Interface: a simple but powerful JDBC wrapper inspired by JDBI","body":"### Welcome to GitHub Pages.\r\n[Java Database Connectivity (JDBC)](https://en.wikipedia.org/wiki/Java_Database_Connectivity) is almost inescapable if you want to talk to a SQL database from Java. However, JDBC is an API that is absolutely no fun to use! MDBI is a wrapper around JDBC that takes the pain away, loosely inspired by [JDBI](http://jdbi.org/) and Harriet Cooper's Phi library for Scala.\r\n\r\n### The basics\r\n\r\nGetting started with MDBI is easy: all you need is a javax.sql.DataSource or Connection:\r\n\r\n    final Connection conn = DriverManager.getConnection(\"jdbc:sqlite::memory:\");\r\n    MDBI.of(conn).execute(sql(\"create table people (name text, age int)\"));\r\n\r\nAs well as executing raw SQL, it is of course possible to interpolate Java objects into the query:\r\n\r\n    final String name = \"Michael O'Hare\";\r\n    MDBI.of(conn).execute(sql(\"insert into people (name, age) values (\").$(name).sql(\", 30)\"));\r\n\r\nTo get back Java objects from the database, simply use a \"query\" method rather than \"execute\":\r\n\r\n    final int age = MDBI.of(conn).queryFirst(sql(\"select age from people\"), int.class);\r\n    println(age); // 30\r\n\r\n### NULL safety\r\n\r\nMost people who work with JDBC have been burned at some point by the fact that it silently\r\nturns NULLs in the database into zeroes, which is almost never what you want. MDBI removes\r\nthis misfeature, so the following query actually throws a NullPointerException:\r\n\r\n    MDBI.of(conn).queryFirst(sql(\"select null\"), int.class);\r\n\r\nOf course, you can still retrieve nulls if you explicitly ask for them:\r\n\r\n    final Integer nully = MDBI.of(conn).queryFirst(sql(\"select null\"), Integer.class);\r\n    println(nully); // null\r\n\r\nNote that database NULLs *are* supported when retrieving primitive doubles and floats, where\r\nthey can be cleanly mapped to NaNs\r\n\r\n    final double nullyDouble = MDBI.of(conn).queryFirst(sql(\"select null\"), double.class);\r\n    println(nullyDouble); // NaN\r\n\r\n### Batch update\r\n\r\nBatch statements are of course fully supported:\r\n\r\n    final List<String> names = Arrays.asList(\"Fry\", \"Leela\");\r\n    final List<Integer> ages = Arrays.asList(1025, 25);\r\n    MDBI.of(conn).updateBatch(sql(\"insert into people (name, age) values (\").$s(names).sql(\",\").$s(ages).sql(\")\"));\r\n\r\nYou can even mix batched and non-batched bits of the query:\r\n\r\n    final List<String> moreNames = Arrays.asList(\"Foo\", \"Bar\");\r\n    final int anotherAge = 13;\r\n    MDBI.of(conn).updateBatch(sql(\"insert into people (name, age) values (\").$s(moreNames).sql(\",\").$(anotherAge).sql(\")\"));\r\n\r\n### Conveniences\r\n\r\nMDBI has built-in support for IN clauses:\r\n\r\n    final List<Integer> foundAges = MDBI.of(conn).queryList(sql(\"select age from people where name \").in(\"Fry\", \"Foo\"), int.class);\r\n    println(foundAges); // [1025, 13]\r\n\r\nThese IN clauses work properly with empty argument lists, even if the database does not normally support\r\nnullary IN clauses (most databases don't -- SQLite is the only one I know of that supports them)\r\n\r\n    final int count = MDBI.of(conn).queryFirst(sql(\"select count(*) from people where name not \").in(), int.class);\r\n    println(count); // 5\r\n\r\nThere is transaction support that's really easy to use (no messing around with the confusing setAutocommit interface)\r\n\r\n    try {\r\n        Transactionally.run(conn, () -> {\r\n            MDBI.of(conn).execute(sql(\"insert into people (name, age) values ('foo', 1)\"));\r\n            throw new IllegalArgumentException(\"Changed my mind!\");\r\n        });\r\n    } catch (IllegalArgumentException _) {}\r\n\r\n### Structured types\r\n\r\nTODO...\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}