<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>MDBI by batterseapower</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">MDBI</h1>
      <h2 class="project-tagline">Max&#39;s DataBase Interface: a simple but powerful JDBC wrapper inspired by JDBI</h2>
      <a href="https://github.com/batterseapower/mdbi" class="btn">View on GitHub</a>
      <a href="https://github.com/batterseapower/mdbi/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/batterseapower/mdbi/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java database access has never been easier.</h3>

<p><a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity">Java Database Connectivity (JDBC)</a> is inescapable if you want to talk to a SQL database from Java. Unfortanately, JDBC is an API that is absolutely no fun to use!</p>

<p>MDBI is a wrapper around JDBC that takes the pain away, loosely inspired by <a href="http://jdbi.org/">JDBI</a>, Benedict Elliott-Smith's Fetch library for Java and Harriet Cooper's Phi library for Scala (both, sadly, proprietary).</p>

<h3>
<a id="the-basics" class="anchor" href="#the-basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>The basics</h3>

<p>Getting started with MDBI is easy: all you need is a <code>javax.sql.DataSource</code> or <code>Connection</code>:</p>

<pre><code>final Connection conn = DriverManager.getConnection("jdbc:sqlite::memory:");
MDBI.of(conn).execute(sql("create table people (name text, age int)"));
</code></pre>

<p>As well as executing raw SQL, it is of course possible to interpolate Java objects into the query:</p>

<pre><code>final String name = "Michael O'Hare";
MDBI.of(conn).execute(sql("insert into people (name, age) values (").$(name).sql(", 30)"));
</code></pre>

<p>To get back Java objects from the database, simply use a "query" method rather than "execute":</p>

<pre><code>final int age = MDBI.of(conn).queryFirst(sql("select age from people"), int.class);
println(age); // 30
</code></pre>

<h3>
<a id="null-safety" class="anchor" href="#null-safety" aria-hidden="true"><span class="octicon octicon-link"></span></a>NULL safety</h3>

<p>Most people who work with JDBC have been burned at some point by the fact that it silently
turns <code>NULL</code>s in the database into zeroes, which is almost never what you want. MDBI removes
this misfeature, so the following query actually throws a NullPointerException:</p>

<pre><code>MDBI.of(conn).queryFirst(sql("select null"), int.class);
</code></pre>

<p>Of course, you can still retrieve nulls if you explicitly ask for them:</p>

<pre><code>final Integer nully = MDBI.of(conn).queryFirst(sql("select null"), Integer.class);
println(nully); // null
</code></pre>

<p>Note that database NULLs <em>are</em> supported when retrieving primitive doubles and floats, where
they can be cleanly mapped to NaNs:</p>

<pre><code>final double nullyDouble = MDBI.of(conn).queryFirst(sql("select null"), double.class);
println(nullyDouble); // NaN
</code></pre>

<h3>
<a id="batch-update" class="anchor" href="#batch-update" aria-hidden="true"><span class="octicon octicon-link"></span></a>Batch update</h3>

<p>Batch statements are of course fully supported:</p>

<pre><code>final List&lt;String&gt; names = Arrays.asList("Fry", "Leela");
final List&lt;Integer&gt; ages = Arrays.asList(1025, 25);
MDBI.of(conn).updateBatch(sql("insert into people (name, age) values (")
                                        .$s(names).sql(",").$s(ages).sql(")"));
</code></pre>

<p>You can even mix batched and non-batched bits of the query:</p>

<pre><code>final List&lt;String&gt; moreNames = Arrays.asList("Foo", "Bar");
final int anotherAge = 13;
MDBI.of(conn).updateBatch(sql("insert into people (name, age) values (")
                                        .$s(moreNames).sql(",").$(anotherAge).sql(")"));
</code></pre>

<h3>
<a id="conveniences" class="anchor" href="#conveniences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conveniences</h3>

<p>MDBI has built-in support for <code>IN</code> clauses:</p>

<pre><code>final List&lt;Integer&gt; foundAges = MDBI.of(conn).queryList(
                     sql("select age from people where name ").in("Fry", "Foo"), int.class);
println(foundAges); // [1025, 13]
</code></pre>

<p>These <code>IN</code> clauses work properly with empty argument lists, even if the database does not normally support
nullary <code>IN</code> clauses (and most databases don't):</p>

<pre><code>final int count = MDBI.of(conn).queryFirst(
                        sql("select count(*) from people where name not ").in(), int.class);
println(count); // 5
</code></pre>

<p>There is also transaction support that's really easy to use (no messing around with the confusing <code>setAutoCommit</code> interface):</p>

<pre><code>try {
    Transactionally.run(conn, () -&gt; {
        MDBI.of(conn).execute(sql("insert into people (name, age) values ('foo', 1)"));
        throw new IllegalArgumentException("Changed my mind!");
    });
} catch (IllegalArgumentException _) {}

final int postTransactionCount = MDBI.of(conn).queryFirst(
                                    sql("select count(*) from people"), int.class);
println(postTransactionCount); // 5
</code></pre>

<h3>
<a id="structured-result-types" class="anchor" href="#structured-result-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Structured result types</h3>

<p>So far we've shown how to retrieve single rows and lists from the datbase. But MDBI has native support for
other useful types of result. For example:</p>

<pre><code>final Map&lt;String, Integer&gt; ageMap = MDBI.of(conn).queryMap(
                            sql("select name, age from people"), String.class, int.class);
println(ageMap.get("Fry")); // 1025
</code></pre>

<p>One option that is particularly handy is the "matrix":</p>

<pre><code>final Object[] matrix = MDBI.of(conn).query(sql("select name, age from people order by name"),
                                            BatchReads.matrix(String.class, int.class));
final String[] nameColumn = (String[])matrix[0];
final int[] ageColumn = (int[])matrix[1];
println(nameColumn[0] + ": " + ageColumn[1]); // Bar: 13
</code></pre>

<p>Alternatively, that can be written as:</p>

<pre><code>final MatrixBatchReadBuilder mrb = MatrixBatchReadBuilder.create();
final Supplier<String[]> names = mrb.add(sql("name"), String.class);
final Supplier<int[]> ages = mrb.addInt(sql("int"));
mrb.buildAndExecute(MDBI.of(conn), columns ->
    sql("select ", columns, " from people order by name"));
println(names.get()[0] + ": " + ages.get()[1]); // Bar: 13
</code></pre>

<h3>
<a id="custom-type-mapping" class="anchor" href="#custom-type-mapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Custom type mapping</h3>

<p>MDBI has great support for Java primitive types, but it can also be extended with support for your own types. Let's say
you have a bean, <code>PersonBean</code>, with <code>Name</code> and <code>Age</code> properties. This works:</p>

<pre><code>final Context ctxt0 = Context.Builder.createDefault()
        .registerRead(PersonBean.class, Reads.bean(PersonBean.class, "Name", "Age"))
        .build();
final PersonBean bean = MDBI.of(ctxt0, conn).queryFirst(
                    sql("select name, age from people order by name"), PersonBean.class);
println(bean.getName()); // Bar
</code></pre>

<p>If you don't like beans, that's no problem. There are also strongly-typed interfaces suitable for immutable data types. For
example, if we have defined a <code>Person</code> type as follows:</p>

<pre><code>public class Person {
    public final String name;
    public final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
</code></pre>

<p>Then we can read this back from the database like so:</p>

<pre><code>final Context ctxt1 = Context.Builder.createDefault()
        .registerRead(Person.class, Reads.tuple(Person.class))
        .build();
final Person person = MDBI.of(ctxt1, conn).queryFirst(
                        sql("select name, age from people order by name"), Person.class);
println(person.name); // Bar
</code></pre>

<p>Or even skip the <code>Context</code> entirely:</p>
<pre><code>MDBI.of(ctxt1, conn).queryFirst(
      sql("select name, age from people order by name"), Reads.tuple(Person.class));
</code></pre>

<p>Or perhaps even get a <code>Person</code> by running something other than a constructor:</p>
<pre><code>final Person person = MDBI.of(ctxt1, conn).queryFirst(
    sql("select name, age from people order by name"),
    Reads.ofFunction(new Object() {
        public f(String name, int age) { return new Person(name, -age); }      
    }));
println(person.age); // -13
</code></pre>

<p>We've shown how you can read your custom types back from the database, but custom types are also usable when you are
constructing SQL queries. You just need to use <code>Context.registerWrite</code> instead of <code>Context.registerRead</code>:</p>

<pre><code>final Context ctxt2 = Context.Builder.createDefault()
        .registerWrite(Person.class, TupleWriteBuilder.&lt;Person&gt;create()
                                        .add(String.class, p -&gt; p.name)
                                        .add(int.class,    p -&gt; p.age)
                                        .build())
        .build();
final Person personToSave = new Person("Max", 29);
MDBI.of(ctxt2, conn).execute(
    sql("insert into people (name, age) values (").$(personToSave).sql(")"));
</code></pre>

<h3>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>There are lots more features besides:</p>

<ul>
<li>Deadlocks are automatically retried. (The retry policy is fully customizable.)</li>
<li>Java 8 date and time types are fully supported</li>
<li>Support for both PreparedStatement and Statement. This can be useful when working with a database
that e.g. scopes the lifetime of temp tables to a prepared statement.</li>
</ul>

<p>All of this comes with no runtime dependencies at all -- you only need the JDK.</p>

<p>To get started, grab a jar from <a href="http://mvnrepository.com/artifact/uk.co.omega-prime/mdbi/">Maven Central</a>
and check out the <a href="http://www.javadoc.io/doc/uk.co.omega-prime/mdbi/">JavaDocs</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/batterseapower/mdbi">MDBI</a> is maintained by <a href="https://github.com/batterseapower">batterseapower</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
